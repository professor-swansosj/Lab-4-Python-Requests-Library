# ==========================================
# Course: Software Defined Networking
# Module: Python Requests Library
# Purpose: Hands on activity for interacting with REST APIs using Python's requests library
# Filename: lab.yml
# Author: Sheldon Swanson
# Version: 1.0
# Created: 10/2025
# Updated: 10/2025
# Notes: Parsers ignore these comments.
# ==========================================
title: "Lab 4 — Python Requests Library"
course: "Software Defined Networking"
module: "Network Automation Fundamentals"
lab_number: 4
time_estimate: "90–120 minutes"

#====================================================
#   ____  _____    _    ____  __  __ _____
#  |  _ \| ____|  / \  |  _ \|  \/  | ____|
#  | |_) |  _|   / _ \ | | | | |\/| |  _|
#  |  _ <| |___ / ___ \| |_| | |  | | |___
#  |_| \_\_____/_/   \_\____/|_|  |_|_____|
#====================================================

repo_tree:
  enabled: true
  max_depth: 3
  ignore:
    - ".git"
    - ".github"
    - "_template"
    - "_render"
    - "__pycache__"
    - ".venv"
    - "venv"
    - "node_modules"
    - ".vscode"
    - ".idea"
    - "*.pyc"
    - "logs"
    - "screens"

readme_topic:

  - title: "The Python requests Library"
    content: |
      The `requests` library is a powerful and user-friendly HTTP library for Python. It allows you to send HTTP requests easily and 
      handle responses in a straightforward manner. With `requests`, you can interact with web services and APIs, making it an essential 
      tool for network automation and data retrieval tasks.

      Key features of the `requests` library include:
      - Simple and intuitive API for sending HTTP requests (GET, POST, PUT, DELETE, etc.).
      - Automatic handling of cookies and sessions.
      - Support for custom headers, query parameters, and request bodies.
      - Built-in JSON support for parsing and generating JSON data.
      - Easy handling of response status codes and error handling.


      In our last lab we made API calls using cURL and Postman. In this lab we will move into Python and use the `requests` library to make 
      similar API calls programmatically. This will allow us to automate interactions with web services and build more complex workflows. Below
      is a simple example of how to use the `requests` library to make a GET request and print the response.

    code_block:
      language: python
      code: |
        import requests

        response = requests.get("https://api.example.com/data")
        print(response.json())

    code_notes: >
      In the example above we use the `requests` library to make a GET request to a REST API endpoint.
      We then print the JSON response from the API. This is a basic example of how to interact with
      web services using Python.

  - title: "Why Use Python for API Interactions?"
    content: |
      Python is a versatile and widely-used programming language that is particularly well-suited for network automation
      and API interactions. Here are some reasons why Python is a great choice for working with APIs:

      1. **Ease of Use**: Python's syntax is clean and easy to read, making it accessible for both beginners and experienced developers.
         This allows you to quickly write and understand code that interacts with APIs.

      2. **Rich Ecosystem**: Python has a vast ecosystem of libraries and frameworks that simplify API interactions. The `requests` library,
         for example, provides a simple and intuitive way to send HTTP requests and handle responses.

      3. **Cross-Platform**: Python is cross-platform, meaning you can run your scripts on various operating systems without modification.

      4. **Integration Capabilities**: Python can easily integrate with other tools and systems, making it ideal for building complex workflows
         that involve multiple APIs and services.

      5. **Community Support**: Python has a large and active community, which means you can find plenty of resources, tutorials, and support
         when working with APIs.

      Overall, Python's simplicity, rich ecosystem, and integration capabilities make it an excellent choice for automating API interactions
      and building network automation solutions.

  - title: "Working with JSON Responses"
    content: |
      When you make an API call, the response is often returned in JSON format. Python provides built-in support for working with JSON data through the `json` module.

      Here are some key points to keep in mind when working with JSON responses in Python:

      1. **Parsing JSON**: You can use the `json.loads()` function to parse a JSON string into a Python dictionary or list. This allows you to
         easily access and manipulate the data.

      2. **Generating JSON**: You can use the `json.dumps()` function to convert a Python dictionary or list into a JSON string. This is useful
         when you need to send JSON data in an API request.

      3. **Accessing Data**: Once you have parsed the JSON response, you can access specific fields using standard dictionary or list indexing.

      4. **Pretty-Printing**: The `pprint` module can be used to pretty-print JSON data, making it easier to read and understand.

      Below is an example of how to parse a JSON response from an API and access specific fields:

    code_block:
      language: python
      code: |
        import requests
        import json
        from pprint import pprint

        response = requests.get("https://api.example.com/data")
        data = json.loads(response.text)
        pprint(data)

        specific_field = data.get("field_name")
        print(specific_field)

    code_notes: >
      In the example above, we make a GET request to an API endpoint and parse the JSON
      response using `json.loads()`. We then pretty-print the entire JSON data using `pprint`
      and access a specific field using the `.get()` method.

  - title: "Retreiving a Joke from the Dad Jokes API"
    content: |
      The Dad Jokes API is a fun and simple API that provides random dad jokes. You can use this API to fetch jokes and display them in your applications.

      Here are some key points about the Dad Jokes API:

      1. **Endpoint**: The main endpoint for fetching a random dad joke is `https://icanhazdadjoke.com/`.

      2. **Headers**: To receive a JSON response, you need to set the `Accept` header to `application/json`.

      3. **Response Format**: The response will be in JSON format and will contain fields such as `id`, `joke`, and `status`.

      Below is an example of how to use the Dad Jokes API to fetch a random joke using Python's `requests` library:

    code_block:
      language: python
      code: |
        import requests

        response = requests.get("https://icanhazdadjoke.com/", headers={"Accept": "application/json"})
        data = response.json()
        print(data["joke"])

    code_notes: >
      In the example above, we make a GET request to the Dad Jokes API with the appropriate
      `Accept` header to receive a JSON response. We then parse the JSON response and
      print the joke field. This is not the only way to write an API call, but it is
      a common pattern you will see.

  - title: "Using the Deck of Cards API"
    content: |
      The Deck of Cards API is a simple API that allows you to create and manipulate decks of playing cards. You can use this API to create a new deck, draw cards, shuffle the deck, and more.

      Here are some key points about the Deck of Cards API:

      1. **Base URL**: The base URL for the Deck of Cards API is `https://deckofcardsapi.com/api/deck/`.

      2. **Creating a Deck**: You can create a new shuffled deck by making a GET request to `https://deckofcardsapi.com/api/deck/new/shuffle/?deck_count=1`.

      3. **Drawing Cards**: To draw cards from a deck, you can make a GET request to `https://deckofcardsapi.com/api/deck/{deck_id}/draw/?count={count}`, where `{deck_id}` is the ID of the deck and `{count}` is the number of cards to draw.

      Below is an example of how to create a new deck and draw cards using Python's `requests` library:

    code_block:
      language: python
      code: |
        import requests

        # Create a new deck
        response = requests.get("https://deckofcardsapi.com/api/deck/new/shuffle/?deck_count=1")
        data = response.json()
        deck_id = data["deck_id"]
        print(f"Created new deck with ID: {deck_id}")

        # Draw cards from the deck
        response = requests.get(f"https://deckofcardsapi.com/api/deck/{deck_id}/draw/?count=2")
        data = response.json()
        print("Drawn cards:")
        for card in data["cards"]:
            print(f"{card['value']} of {card['suit']}")

  - title: "Adding User Interaction"
    content: |
      Adding user interaction to your scripts can make them more dynamic and engaging. You can use Python's built-in `input()` function to prompt the user for input and make decisions based on their responses.

      Here are some key points about adding user interaction:

      1. **Prompting for Input**: Use the `input()` function to display a prompt and wait for the user to enter a response.

      2. **Processing Input**: You can process the user's input by normalizing it (e.g., converting to lowercase, stripping whitespace) and using conditionals to determine the next steps.

      3. **Loops**: You can use loops (e.g., `while` loops) to repeatedly prompt the user until they provide valid input or choose to exit.

      Below is an example of how to add user interaction to a script that fetches jokes from the Dad Jokes API:

    code_block:
      language: python
      code: |
        import requests

        while True:
            response = requests.get("https://icanhazdadjoke.com/", headers={"Accept": "application/json"})
            data = response.json()
            print(data["joke"])

            user_input = input("Do you want another joke? (yes/no): ").strip().lower()
            if user_input != "yes":
                break

    code_notes: >
      In the example above, we use a `while` loop to continuously fetch and display jokes
      from the Dad Jokes API. After displaying a joke, we prompt the user to see if they want
      another joke. If the user enters anything other than "yes", the loop breaks and the script ends.

#========================================================================
#
#   ___ _   _ ____ _____ ____  _   _  ____ _____ ___ ___  _   _ ____
#  |_ _| \ | / ___|_   _|  _ \| | | |/ ___|_   _|_ _/ _ \| \ | / ___|
#   | ||  \| \___ \ | | | |_) | | | | |     | |  | | | | |  \| \___ \
#   | || |\  |___) || | |  _ <| |_| | |___  | |  | | |_| | |\  |___) |
#  |___|_| \_|____/ |_| |_| \_\\___/ \____| |_| |___\___/|_| \_|____/
#
#========================================================================
# LAB 4 — THE PYTHON REQUESTS LIBRARY
# Software Defined Networking • Florida State College at Jacksonville
# Worth 75 points

# OBJECTIVES
objectives:
  - "Use the Python `requests` library to call public APIs."
  - "Handle headers, status codes, and JSON parsing robustly."
  - "Build a small CLI utility that prints a specific JSON field (Dad Jokes)."
  - "Implement a dynamic, multi-player 'highest card' game with Deck of Cards."
  - "Log meaningful events for autograding and troubleshooting."
  - "Write artifacts (raw JSON, human-readable summaries) to the repo."

# PREREQUISITES
python_version: "3.11"
accounts: ["GitHub"]
devices: ["Public APIs (Dad Jokes, Deck of Cards)"]

prereq:
  - "Intermediate Python: functions, loops, conditionals, f-strings."
  - "Basic error handling with try/except and the logging module."
  - "Comfort reading API docs and inspecting JSON structures."
  - "GitHub Classroom workflow (clone, commit, push, PR)."
  - "Prior Lab 3 experience with cURL/jq or equivalent."

# OVERVIEW
overview: >
  You’ll author two Python programs using the `requests` library. First, a simple script that fetches a
  single Dad Joke and prints only the joke text to stdout (and optionally saves it to a file). Second,
  you’ll build a dynamic 'highest card wins' game powered by the Deck of Cards API: any number of players
  draw one card, the highest rank wins; ties re-draw among tied players until a single winner emerges.
  You’ll log markers to `logs/lab4.log` for autograding and save artifacts under `data/`.

# SETUP
before_you_begin: >
  Open the dev container (or ensure Python 3.11 + `requests` is installed).
  Verify `import requests` works, and that you can write to `data/` and `logs/`.

# RESOURCES
resources:
  - { title: "Requests (Python)", url: "https://requests.readthedocs.io/en/latest/" }
  - { title: "Dad Jokes API", url: "https://icanhazdadjoke.com/api" }
  - { title: "Deck of Cards API", url: "https://deckofcardsapi.com/" }
  - { title: "pprint (Python)", url: "https://docs.python.org/3/library/pprint.html" }
  - { title: "logging (Python)", url: "https://docs.python.org/3/library/logging.html" }

# DELIVERABLES
deliverables:
  - "`src/tell_me_a_joke.py` prints only the joke line to stdout and logs success."
  - "`src/high_card.py` implements the dynamic highest-card game with tie-breaker rounds."
  - "`logs/lab4.log` contains required autograder markers from both scripts."
  - "`data/joke.json` and `data/joke.txt` generated by the joke script."
  - "`data/high_card_rounds.json` (optional but recommended) and `data/high_card_result.txt` from the game."
  - "Pull request open to main branch with all artifacts."

# STEPS
steps:
  - title: "Clone the Repository"
    goal: "Get your starter locally."
    actions: |
      Clone your Classroom repo and `cd` into it. Create `src/`, `data/`, and `logs/` if missing.
      Initialize the log: `echo 'LAB4_START' >> logs/lab4.log`
    done_when: |
      - Repo folders exist.
      - `LAB4_START` present in `logs/lab4.log`.
    log_marker: "LAB4_START"

  - title: "Open Dev Container"
    goal: "Standardize environment."
    actions: |
      Reopen in container and verify:
        - `python --version` shows 3.11+
        - `python -c "import requests; print('OK')"` prints OK
      Append `[STEP 2] Dev Container Started` to `logs/lab4.log`.
    done_when: |
      - Python 3.11+ confirmed, requests import OK.
      - Log includes `[STEP 2] Dev Container Started`.
    log_marker: "[STEP 2] Dev Container Started"

  - title: "Script 1 — tell_me_a_joke.py"
    goal: "Fetch a joke and print only the joke text."
    actions: |
      Create `src/tell_me_a_joke.py` that:
        - Uses `requests.get('https://icanhazdadjoke.com/', headers={'Accept':'application/json'}, timeout=10)`
        - Checks `response.status_code == 200`; log `LAB4_JOKE_HTTP_OK` or `LAB4_ERR` on failure.
        - Parses JSON, extracts `.get('joke')`, prints ONLY the joke line to stdout (no extra text).
        - Saves full JSON to `data/joke.json` and the joke line to `data/joke.txt`.
        - Logs `LAB4_JOKE_JSON_OK` and `LAB4_JOKE_PRINTED` on success.
    done_when: |
      - `data/joke.json` and `data/joke.txt` exist and are non-empty.
      - Terminal output shows only the joke line.
      - Log contains `LAB4_JOKE_HTTP_OK`, `LAB4_JOKE_JSON_OK`, `LAB4_JOKE_PRINTED`.
    log_marker: "LAB4_JOKE_HTTP_OK, LAB4_JOKE_JSON_OK, LAB4_JOKE_PRINTED"

  - title: "Script 2 — high_card.py"
    goal: "Dynamic, multi-player 'highest card' with tie-breakers."
    actions: |
      Create `src/high_card.py` that:
        - Creates a new shuffled deck: GET `/api/deck/new/shuffle/?deck_count=1`
          * Capture `deck_id`; log `LAB4_DECK_CREATE_OK`.
        - Prompts for number of players (>=2). Validate input; re-prompt or exit with `LAB4_ERR` if invalid.
        - Draws one card per player: GET `/api/deck/{deck_id}/draw/?count=<players>`
          * Map ranks {2..10,J,Q,K,A} -> {2..14}. Store player->card->value.
          * Log `LAB4_DRAW_OK` and save raw JSON to `data/high_card_rounds.json` (append or structure per round).
        - Determines the highest value; if tie among N players, re-draw **only for tied players**:
          * Repeat draw until exactly one winner remains.
          * For each tie round, log `LAB4_TIE_ROUND` and append round data.
        - Prints a clear summary of each round and the **final winner**.
          * Save a final summary to `data/high_card_result.txt`; log `LAB4_GAME_END`.
        - Handles and logs network errors (`requests.Timeout`, `requests.RequestException`) as `LAB4_ERR`.
    done_when: |
      - Deck created; draw(s) executed with rank mapping and tie-breakers if needed.
      - `data/high_card_result.txt` describes the winner and shows at least one round.
      - Log contains `LAB4_DECK_CREATE_OK`, `LAB4_DRAW_OK`, optional `LAB4_TIE_ROUND` (if tie), and `LAB4_GAME_END`.
    log_marker: "LAB4_DECK_CREATE_OK, LAB4_DRAW_OK, LAB4_TIE_ROUND, LAB4_GAME_END"

  - title: "Finalize and Submit"
    goal: "Push artifacts and open PR."
    actions: |
      Ensure the script(s) add `LAB4_END` to `logs/lab4.log` at completion (or echo it before commit).
      Commit and push all changes. Open a pull request targeting `main`.
    done_when: |
      - PR is open; artifacts present under `src/`, `data/`, and `logs/`.
      - `LAB4_END` recorded in `logs/lab4.log`.
    log_marker: "LAB4_END"

# FAQ + TROUBLESHOOTING
faq:
  - q: "Dad Jokes returned HTML instead of JSON."
    a: "Add `headers={'Accept':'application/json'}` to the request."
  - q: "I’m getting timeouts."
    a: "Set `timeout=10` on requests and catch `requests.Timeout` to log `LAB4_ERR` gracefully."
  - q: "Face cards compare weirdly."
    a: "Normalize ranks once: map J=11, Q=12, K=13, A=14, then compare integers."

tips:
  - title: "Keep logs deterministic"
    symptom: "Autograder can’t find markers."
    fix: "Log exact tokens provided and write `logging.basicConfig(filename='logs/lab4.log', level=logging.INFO)` once."
  - title: "Don’t print extra text in joke script"
    symptom: "Joke line buried in other output."
    fix: "The grader expects just the joke text on stdout; put explanations in the log or a file."
  - title: "Tie-breaker loop safety"
    symptom: "Infinite loop on repeated ties."
    fix: "Limit tie rounds (e.g., 10) and fail gracefully with `LAB4_ERR` if exceeded."

# GRADING
grading:
  total_points: 75
  rows:
    - { step: "Step 2", requirement: "Dev container started; requests available", points: 5 }
    - { step: "Script 1", requirement: "HTTP OK with Accept header (`LAB4_JOKE_HTTP_OK`)", points: 5 }
    - { step: "Script 1", requirement: "JSON parsed; joke extracted (`LAB4_JOKE_JSON_OK`)", points: 5 }
    - { step: "Script 1", requirement: "Printed-only joke + saved artifacts (`LAB4_JOKE_PRINTED`)", points: 5 }
    - { step: "Script 2", requirement: "Deck created; deck_id captured (`LAB4_DECK_CREATE_OK`)", points: 5 }
    - { step: "Script 2", requirement: "Validated dynamic player input; initial draw OK (`LAB4_DRAW_OK`)", points: 10 }
    - { step: "Script 2", requirement: "Rank mapping + round winner logic; tie-breakers (`LAB4_TIE_ROUND` if applicable)", points: 10 }
    - { step: "Script 2", requirement: "Final winner summary saved (`LAB4_GAME_END` + result file)", points: 10 }
    - { step: "Script 2", requirement: "Handled at least one error path and logged `LAB4_ERR`", points: 5 }
    - { step: "Submission", requirement: "PR open; all markers present in `logs/lab4.log`", points: 15 }

# AUTOGRADING
autograder:
  log_path: "logs/lab4.log"
  required_markers:
    - "LAB4_START"
    - "[STEP 2] Dev Container Started"
    - "LAB4_JOKE_HTTP_OK"
    - "LAB4_JOKE_JSON_OK"
    - "LAB4_JOKE_PRINTED"
    - "LAB4_DECK_CREATE_OK"
    - "LAB4_DRAW_OK"
    - "LAB4_TIE_ROUND"
    - "LAB4_GAME_END"
    - "LAB4_END"
  optional_markers:
    - "LAB4_ERR"

# SUBMISSION CHECKLIST
submission_checklist:
  - "`src/tell_me_a_joke.py` prints only the joke, no extra text."
  - "`src/high_card.py` supports dynamic players and tie-breakers."
  - "Artifacts exist: `data/joke.json`, `data/joke.txt`, and `data/high_card_result.txt` (+ optional rounds JSON)."
  - "`logs/lab4.log` contains all required markers for both scripts."
  - "Pull request open to `main` before deadline."

license: "© 2025 Sheldon Swanson — Classroom use."
