# ==========================================
# Course: Software Defined Networking
# Module: Python Requests Library
# Purpose: Hands on activity for interacting with REST APIs using Python's requests library
# Filename: lab.yml
# Author: Sheldon Swanson
# Version: 1.0
# Created: 10/2025
# Updated: 10/2025
# Notes: Parsers ignore these comments.
# ==========================================
title: "Lab 4 — Python Requests Library"
course: "Software Defined Networking"
module: "Network Automation Fundamentals"
lab_number: 4
time_estimate: "90–120 minutes"

#====================================================
#   ____  _____    _    ____  __  __ _____
#  |  _ \| ____|  / \  |  _ \|  \/  | ____|
#  | |_) |  _|   / _ \ | | | | |\/| |  _|
#  |  _ <| |___ / ___ \| |_| | |  | | |___
#  |_| \_\_____/_/   \_\____/|_|  |_|_____|
#====================================================

repo_tree:
  enabled: true
  max_depth: 3
  ignore:
    - ".git"
    - ".github"
    - "_template"
    - "_render"
    - "__pycache__"
    - ".venv"
    - "venv"
    - "node_modules"
    - ".vscode"
    - ".idea"
    - "*.pyc"
    - "logs"
    - "screens"

readme_topic:

  - title: "The Python requests Library"
    content: |
      The `requests` library is a powerful and user-friendly HTTP library for Python. It allows you to send HTTP requests easily and 
      handle responses in a straightforward manner. With `requests`, you can interact with web services and APIs, making it an essential 
      tool for network automation and data retrieval tasks.

      Key features of the `requests` library include:
      - Simple and intuitive API for sending HTTP requests (GET, POST, PUT, DELETE, etc.).
      - Automatic handling of cookies and sessions.
      - Support for custom headers, query parameters, and request bodies.
      - Built-in JSON support for parsing and generating JSON data.
      - Easy handling of response status codes and error handling.


      In our last lab we made API calls using cURL and Postman. In this lab we will move into Python and use the `requests` library to make 
      similar API calls programmatically. This will allow us to automate interactions with web services and build more complex workflows. Below
      is a simple example of how to use the `requests` library to make a GET request and print the response.

    code_block:
      language: python
      code: |
        import requests

        response = requests.get("https://api.example.com/data")
        print(response.json())

    code_notes: >
      In the example above we use the `requests` library to make a GET request to a REST API endpoint.
      We then print the JSON response from the API. This is a basic example of how to interact with
      web services using Python.

  - title: "Why Use Python for API Interactions?"
    content: |
      Python is a versatile and widely-used programming language that is particularly well-suited for network automation
      and API interactions. Here are some reasons why Python is a great choice for working with APIs:

      1. **Ease of Use**: Python's syntax is clean and easy to read, making it accessible for both beginners and experienced developers.
         This allows you to quickly write and understand code that interacts with APIs.

      2. **Rich Ecosystem**: Python has a vast ecosystem of libraries and frameworks that simplify API interactions. The `requests` library,
         for example, provides a simple and intuitive way to send HTTP requests and handle responses.

      3. **Cross-Platform**: Python is cross-platform, meaning you can run your scripts on various operating systems without modification.

      4. **Integration Capabilities**: Python can easily integrate with other tools and systems, making it ideal for building complex workflows
         that involve multiple APIs and services.

      5. **Community Support**: Python has a large and active community, which means you can find plenty of resources, tutorials, and support
         when working with APIs.

      Overall, Python's simplicity, rich ecosystem, and integration capabilities make it an excellent choice for automating API interactions
      and building network automation solutions.

  - title: "Working with JSON Responses"
    content: |
      When you make an API call, the response is often returned in JSON format. Python provides built-in support for working with JSON data through the `json` module.

      Here are some key points to keep in mind when working with JSON responses in Python:

      1. **Parsing JSON**: You can use the `json.loads()` function to parse a JSON string into a Python dictionary or list. This allows you to
         easily access and manipulate the data.

      2. **Generating JSON**: You can use the `json.dumps()` function to convert a Python dictionary or list into a JSON string. This is useful
         when you need to send JSON data in an API request.

      3. **Accessing Data**: Once you have parsed the JSON response, you can access specific fields using standard dictionary or list indexing.

      4. **Pretty-Printing**: The `pprint` module can be used to pretty-print JSON data, making it easier to read and understand.

      Below is an example of how to parse a JSON response from an API and access specific fields:

    code_block:
      language: python
      code: |
        import requests
        import json
        from pprint import pprint

        response = requests.get("https://api.example.com/data")
        data = json.loads(response.text)
        pprint(data)

        specific_field = data.get("field_name")
        print(specific_field)

    code_notes: >
      In the example above, we make a GET request to an API endpoint and parse the JSON
      response using `json.loads()`. We then pretty-print the entire JSON data using `pprint`
      and access a specific field using the `.get()` method.

  - title: "Retreiving a Joke from the Dad Jokes API"
    content: |
      The Dad Jokes API is a fun and simple API that provides random dad jokes. You can use this API to fetch jokes and display them in your applications.

      Here are some key points about the Dad Jokes API:

      1. **Endpoint**: The main endpoint for fetching a random dad joke is `https://icanhazdadjoke.com/`.

      2. **Headers**: To receive a JSON response, you need to set the `Accept` header to `application/json`.

      3. **Response Format**: The response will be in JSON format and will contain fields such as `id`, `joke`, and `status`.

      Below is an example of how to use the Dad Jokes API to fetch a random joke using Python's `requests` library:

    code_block:
      language: python
      code: |
        import requests

        response = requests.get("https://icanhazdadjoke.com/", headers={"Accept": "application/json"})
        data = response.json()
        print(data["joke"])

    code_notes: >
      In the example above, we make a GET request to the Dad Jokes API with the appropriate
      `Accept` header to receive a JSON response. We then parse the JSON response and
      print the joke field. This is not the only way to write an API call, but it is
      a common pattern you will see.

  - title: "Using the Deck of Cards API"
    content: |
      The Deck of Cards API is a simple API that allows you to create and manipulate decks of playing cards. You can use this API to create a new deck, draw cards, shuffle the deck, and more.

      Here are some key points about the Deck of Cards API:

      1. **Base URL**: The base URL for the Deck of Cards API is `https://deckofcardsapi.com/api/deck/`.

      2. **Creating a Deck**: You can create a new shuffled deck by making a GET request to `https://deckofcardsapi.com/api/deck/new/shuffle/?deck_count=1`.

      3. **Drawing Cards**: To draw cards from a deck, you can make a GET request to `https://deckofcardsapi.com/api/deck/{deck_id}/draw/?count={count}`, where `{deck_id}` is the ID of the deck and `{count}` is the number of cards to draw.

      Below is an example of how to create a new deck and draw cards using Python's `requests` library:

    code_block:
      language: python
      code: |
        import requests

        # Create a new deck
        response = requests.get("https://deckofcardsapi.com/api/deck/new/shuffle/?deck_count=1")
        data = response.json()
        deck_id = data["deck_id"]
        print(f"Created new deck with ID: {deck_id}")

        # Draw cards from the deck
        response = requests.get(f"https://deckofcardsapi.com/api/deck/{deck_id}/draw/?count=2")
        data = response.json()
        print("Drawn cards:")
        for card in data["cards"]:
            print(f"{card['value']} of {card['suit']}")

  - title: "Adding User Interaction"
    content: |
      Adding user interaction to your scripts can make them more dynamic and engaging. You can use Python's built-in `input()` function to prompt the user for input and make decisions based on their responses.

      Here are some key points about adding user interaction:

      1. **Prompting for Input**: Use the `input()` function to display a prompt and wait for the user to enter a response.

      2. **Processing Input**: You can process the user's input by normalizing it (e.g., converting to lowercase, stripping whitespace) and using conditionals to determine the next steps.

      3. **Loops**: You can use loops (e.g., `while` loops) to repeatedly prompt the user until they provide valid input or choose to exit.

      Below is an example of how to add user interaction to a script that fetches jokes from the Dad Jokes API:

    code_block:
      language: python
      code: |
        import requests

        while True:
            response = requests.get("https://icanhazdadjoke.com/", headers={"Accept": "application/json"})
            data = response.json()
            print(data["joke"])

            user_input = input("Do you want another joke? (yes/no): ").strip().lower()
            if user_input != "yes":
                break

    code_notes: >
      In the example above, we use a `while` loop to continuously fetch and display jokes
      from the Dad Jokes API. After displaying a joke, we prompt the user to see if they want
      another joke. If the user enters anything other than "yes", the loop breaks and the script ends.

#========================================================================
#
#   ___ _   _ ____ _____ ____  _   _  ____ _____ ___ ___  _   _ ____
#  |_ _| \ | / ___|_   _|  _ \| | | |/ ___|_   _|_ _/ _ \| \ | / ___|
#   | ||  \| \___ \ | | | |_) | | | | |     | |  | | | | |  \| \___ \
#   | || |\  |___) || | |  _ <| |_| | |___  | |  | | |_| | |\  |___) |
#  |___|_| \_|____/ |_| |_| \_\\___/ \____| |_| |___\___/|_| \_|____/
#
#========================================================================

objectives:
  - "Use the Python `requests` library to send HTTP requests and receive responses."
  - "Export a request from Postman into Python and run it as a script."
  - "Parse JSON into Python dicts/lists and extract specific fields."
  - "Pretty-print JSON and compose f-strings for clear output."
  - "Implement loops and conditionals for user interaction."
  - "Work with a multi-step API flow (Deck of Cards: create deck → draw cards)."
  - "Build a mini game using API data and comparison logic."

python_version: "3.11"
accounts: ["GitHub"]
devices: ["Public APIs (Dad Jokes, Deck of Cards)"]

overview: >
  Move from cURL/Postman into actual Python automation with `requests`. You’ll fetch JSON,
  pretty-print and extract fields, add a small user-driven loop, then chain API calls with
  Deck of Cards to build a tiny “highest card wins” game.

before_you_begin: >
  Open the dev container and verify outbound HTTPS works. Confirm `python --version` and that
  `requests` is importable. Create the folders `logs/`, `data/raw/`, and `data/reports/` if needed.

resources:
  - { title: "Requests (Python)", url: "https://requests.readthedocs.io/en/latest/" }
  - { title: "Dad Jokes API", url: "https://icanhazdadjoke.com/api", note: "Use Accept: application/json to get JSON." }
  - { title: "Deck of Cards API", url: "https://deckofcardsapi.com/", note: "Create deck → store deck_id → draw." }
  - { title: "pprint (Python)", url: "https://docs.python.org/3/library/pprint.html" }

faq:
  - q: "I got HTML back instead of JSON—why?"
    a: "Add a header like `Accept: application/json` for APIs (e.g., Dad Jokes)."
  - q: "My draw fails on the Deck API."
    a: "You must pass the exact `deck_id` returned from the create call into the draw call."
  - q: "Face cards compare weirdly."
    a: "Map values once: {2..10, JACK:11, QUEEN:12, KING:13, ACE:14} and compare integers."

deliverables:
  readme_summary: "Standard README with objectives, resources, grading, and tips."
  instructions_summary: "Stepwise INSTRUCTIONS for four scripts, artifacts under data/, and logs under logs/."

grading:
  total_points: 75
  rows:
    - { step: "2", requirement: "`[STEP 2] Dev Container Started` appears in `logs/lab4_devcontainer.log`", points: 5 }
    - { step: "3", requirement: "`logs/jokes_postman_export.log` has START, POSTMAN_EXPORT_RUN, HTTP_OK, RAW_PRINTED, END", points: 10 }
    - { step: "4", requirement: "`logs/jokes_json.log` shows JSON header set, HTTP_OK, JSON_LOADED, PPRINT_OK", points: 10 }
    - { step: "5", requirement: "`logs/jokes_json.log` includes JOKE_FIELD_OK and JOKE_PRINTED", points: 5 }
    - { step: "6", requirement: "`logs/jokes_loop.log` shows LOOP_BEGIN, JOKE_FIELD_OK, and LOOP_CONTINUE/LOOP_STOP", points: 10 }
    - { step: "7", requirement: "`logs/high_card.log` shows DECK_CREATE_OK with valid deck_id", points: 5 }
    - { step: "8", requirement: "`logs/high_card.log` shows card draws, comparison, and winner/tie for ≥1 round", points: 15 }
    - { step: "9", requirement: "Any script log includes an `LAB4_ERR ...` marker for a handled error", points: 5 }
    - { step: "10", requirement: "All artifacts committed/pushed and PR opened", points: 10 }

tips:
  - title: "Got HTML instead of JSON"
    symptom: "Output looks like an HTML page"
    fix: "Set `headers={'Accept': 'application/json'}`."
  - title: "Requests hangs"
    symptom: "Script stuck on network call"
    fix: "Pass `timeout=10` and handle `requests.Timeout`."
  - title: "KeyError on JSON"
    symptom: "`data['joke']` explodes"
    fix: "Inspect full JSON once; use `.get('joke')` and validate."
  - title: "Deck exhausted"
    symptom: "Draw returns too few cards"
    fix: "Recreate or reshuffle when `remaining` is 0."
  - title: "Logs missing"
    symptom: "Autograder finds no markers"
    fix: "Use the provided `log(...)` helper and write to the correct file per script."

autograder:
  log_path: "logs/*.log"
  required_markers:
    - "LAB4_START"
    - "[STEP 2] Dev Container Started"
    - "LAB4_POSTMAN_EXPORT_RUN"
    - "LAB4_HTTP_OK"
    - "LAB4_RAW_PRINTED"
    - "LAB4_ACCEPT_JSON_HEADER_SET"
    - "LAB4_JSON_LOADED"
    - "LAB4_PPRINT_OK"
    - "LAB4_JOKE_FIELD_OK"
    - "LAB4_JOKE_PRINTED"
    - "LAB4_LOOP_BEGIN"
    - "LAB4_LOOP_CONTINUE"
    - "LAB4_LOOP_STOP"
    - "LAB4_DECK_CREATE_OK"
    - "LAB4_DRAW"
    - "LAB4_COMPARE"
    - "LAB4_ROUND_WINNER"
    - "LAB4_ROUND_TIE"
    - "LAB4_GAME_END"
    - "LAB4_ERR"
    - "LAB4_END"

submission_checklist:
  - "logs/jokes_postman_export.log includes START/END and required markers."
  - "logs/jokes_json.log includes JSON header, HTTP_OK, JSON_LOADED, PPRINT_OK, JOKE_FIELD_OK, JOKE_PRINTED."
  - "logs/jokes_loop.log shows multiple rounds with LOOP markers."
  - "logs/high_card.log shows DECK_CREATE_OK, per-round DRAW/COMPARE/WINNER (or TIE), and GAME_END."
  - "data/raw/jokes_last.json present."
  - "data/raw/deck_draw_last.json present."
  - "data/reports/joke_of_the_day.txt present."
  - "data/reports/high_card_results.txt present."

steps:
  - title: "Clone the Repository"
    goal: "Get your Classroom repo locally."
    actions: "Clone, `cd` into it, and ensure `logs/`, `data/raw/`, and `data/reports/` exist."
    done_when: "You see the folders above; Git is tracking changes."
    log_marker: "LAB4_START"

  - title: "Open a Dev Container"
    goal: "Use the standardized environment."
    actions: "Open in VS Code and reopen in container. Wait for READY, confirm Python."
    done_when: "`[STEP 2] Dev Container Started` is written to `logs/lab4_devcontainer.log`."
    log_marker: "[STEP 2] Dev Container Started"

  - title: "Export from Postman → Python"
    goal: "Move a Dad Jokes request from Postman into code."
    actions: "Export as Python; save to `src/jokes_postman_export.py`; run and print response."
    done_when: "Raw response prints and required log markers exist."
    log_marker: "LAB4_POSTMAN_EXPORT_RUN, LAB4_HTTP_OK, LAB4_RAW_PRINTED"

  - title: "Request JSON + pretty-print"
    goal: "Parse and inspect JSON cleanly."
    actions: "Add `Accept: application/json`; save last JSON to `data/raw/jokes_last.json`; pretty-print with `pprint` and write a one-line report to `data/reports/joke_of_the_day.txt`."
    done_when: "`LAB4_JSON_LOADED` and `LAB4_PPRINT_OK` appear; report file exists."
    log_marker: "LAB4_ACCEPT_JSON_HEADER_SET, LAB4_HTTP_OK, LAB4_JSON_LOADED, LAB4_PPRINT_OK, LAB4_JOKE_FIELD_OK, LAB4_JOKE_PRINTED"

  - title: "Add a simple loop"
    goal: "Fetch jokes until user stops."
    actions: "Normalize input (`.strip().lower()`); loop with `y/n`; handle invalid input; log each round."
    done_when: "Loop runs at least twice; proper LOOP_* markers present."
    log_marker: "LAB4_LOOP_BEGIN, LAB4_LOOP_CONTINUE, LAB4_LOOP_STOP"

  - title: "Create a deck (Deck of Cards)"
    goal: "Chain calls with saved state."
    actions: "Create a shuffled deck; store `deck_id`; log success or failure."
    done_when: "`LAB4_DECK_CREATE_OK deck_id=...` exists in `logs/high_card.log`."
    log_marker: "LAB4_DECK_CREATE_OK"

  - title: "Highest card wins"
    goal: "Use API data to power a tiny game."
    actions: "From same deck, draw one card for player and CPU; map face values; compare; handle ties; append round summaries to `data/reports/high_card_results.txt`."
    done_when: "At least one round logged with DRAW/COMPARE/WINNER (or TIE); `GAME_END` when exiting."
    log_marker: "LAB4_DRAW, LAB4_COMPARE, LAB4_ROUND_WINNER, LAB4_ROUND_TIE, LAB4_GAME_END"

  - title: "Error handling & polish"
    goal: "Fail predictably."
    actions: "Wrap requests in `try/except` with `timeout=`; on handled error, write `LAB4_ERR type=<ExceptionName> msg=\"...\"` to the relevant log."
    done_when: "One controlled `LAB4_ERR` appears in any script log."
    log_marker: "LAB4_ERR"

  - title: "Commit, push, open PR"
    goal: "Submit work for grading."
    actions: "Commit source + artifacts + logs; push; open a PR to `main`."
    done_when: "PR is open and green."
    log_marker: "LAB4_END"

license: "© 2025 Your Name — Classroom use."

